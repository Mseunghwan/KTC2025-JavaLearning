Chapter 1. 자바 기초 문법 다지기

챕터 1-1
Java - Write Once, Run Anywhere!

JDK - 자바 프로그램을 개발할 때 필요한 개발 도구 모음
--> 구성요소 중 대표적인 두 개?
Javac - 자바 컴파일러
JVM - 자바 가상 머신

Javac(Java Compiler)?
.java로 작성되는 자바 언어를 바이트코드(.class)로 변환해 준다
바이트 코드는 JVM이 해석할 수 있는 코드

JVM(Java Virtual Machine)?
바이트 코드를 해석하고 자바 프로그램을 실행시키는 역할
JVM 덕에 실행환경에 관계없이 자바 프로그램 동작 가능

이 두 가지 대표적인 역할 덕분에 플랫폼 독립적으로 사용 가능

객체지향 - 모든 것이 클래스

모든 것이 객체(class)
--> 자바의 세계는 모두 객체
--> 객체와 클래스는 개념적으론 다르지만 실무에선 혼용
--> 자바에서 코드를 작성할 때 서로 관련있는 기능 하나가 하나의 클래스

거대한 생태계
Java는 오랜 시간 동안 선호되었기에 생태계가 거대하다

챕터 1-2
컴퓨터의 기억방식

RAM, 휘발성, 보조기억장치, 바이트, 비트

주기억장치 - 메모리(RAM : Random Access Memory)
특징 ? 인간의 뇌 같은, 영구적으로 저장 못한다(휘발성) / 빠른 속도

보조기억장치 - 하드디스크(HDD / SSD)
--> 파일을 영구적으로 저장 / 느린 속도

컴퓨터가 메모리를 관리하는 방법(중요)
컴퓨터 메모리는 1바이트 단위로 주소 매겨져 관리
1byte = 8bit
1bit = 0, 1

메모리를 절약하려면?
필요한 데이터 크기를 판단, 적당한 크기를 활용해 저장해야


챕터 1-3
자바 프로젝트 관리

카멜케이스와 스네이크케이스

패키지(폴더)
src는 패키지 X, 그 내부에 생성
패키지 - 폴더처럼 파일(클래스)를 정리, 관리
파일 생성 하면 위에 package ---

클래스 명은 첫 글자가 대문자 + 카멜케이스


챕터 1-4
변수(데이터의 저장 공간)

자료형
--> 데이터의 크기를 결정하는 규칙
boolean(1 byte)
char(2 byte)
byte(1 byte)
short(2 byte)
int(4 byte)
long(8 byte)
float(4 byte) - 약 소수점 6 ~ 7 자리 까지
double(8 byte) - 약 소수점 15 ~ 17 자리 까지

float에 소수점 더 들어가게 되면 반올림 해서 7자리까지 표현한다

형변환
다운 캐스팅 : 큰 데이터 -> 작은 상자
업 캐스팅 : 작은 데이터 -> 큰 상자

문자열 데이터

챕터 1-5
입출력 - 프로그램과 사용자 간 대화

입력(Scanner)
Scanner scanner = new Scanner(System.in);

System.out.print("좋아하는 문장을 입력 : ");
String sentence = scanner.nextLine();
System.out.println("sentence = " + sentence);

숫자는 nextInt()
int intbox = scanner.nextInt();

챕터 1-6
연산자
사칙연산 외 mod 연산(%)
복합대입 연산자 - 누적값 구할 때 자주 사용
증감연산자 - 전위연산, 후위연산
비교연산자(같음, 다름, 크기비교)
논리연산자(&&, ||, !) - 우선순위는 ! -> && -> ||
문자열비교 .equals 사용해야, ==는 메모리 주소를 비교하는 것이기에

챕터 1-7
조건문
if, switch

챕터 1-8
반복문

챕터 1-9
배열
1차원, 2차원 배열

챕터 1-10
메서드 - 모듈화의 시작
메서드 명은 카멜케이스로

반환 자료형, 메서드 이름, 매개변수, 작업내용, 반환값 순


Chapter 2. 객체지향 이해하기
챕터 2-1
클래스와 객체
클래스?
객체를 만들때 필요한 청사진

객체? 실제로 존재하는 것 --> 어떠한 논리나 개념이라고도 할 수

Person.class 만들어 사람 객체 여러개 만들어 보기
객체를 만들때 new라는 키워드 사용
--> 객체를 만드는 과정을 인스턴스화라고 표현한다

클래스 구조는 속성, 생성자, 기능

생성자 - 조립설명서
--> 객체를 만들때 사용
--> 생성자가 없으면 클래스를 객체화 시킬 수 없다
--> 생성자 명시하지 않아도 인스턴스화 할 수 있는 이유? 기본 생성자

2-2 JVM 메모리 영역

JVM 메모리 구조
크게 Method Area, Stack Area, Heap Area
Method Area : 파일들이 착착 쌓여있는
Stack Area : 접시 쌓듯 프로그램 실행에 따라 쌓이는 메서드들
Heap Area : 객체가 저장되어 있는 공간

Main 이라는 접시 안에 이름, 나이 다 쌓임
person 객체 생성하면, 객체는 Heap 영역안이라
생성자 호출해 name, age 지정해주면 Heap 영역에 쌓인다
생성자 끝나고 객체가 완전히 Heap에 생성되고,
personA가 객체를 가리키는게 아니라 객체의 힙 영역의 위치를 가리킨다

personA.introduce 실행하면
메인 접시(Stack)에서 frame이 하나 더 쌓인다 - 그게 끝나면 접시에서 빠져나감
Stack 내 각 접시들 끼리 가진 변수는 지역변수 이기 때문에(접시 내에 있으니)
다른 접시에서 호출 불가

Method(static) 영역 이해하기
--> 프로그램 실행 시 작성한 모든 파일의 데이터가 Method(static) 영역에 저장
--> 프로그램 실행 시점에 한 번만 저장
--> Method 영역에 저장된 데이터는 프로그램 전체에서 공용 활용 가능
--> static으로 선언된 변수와 메서드들이 이 공간에 위치, 공용사용 가능

Heap 영역 이해하기
--> new 키워드로 생성된 객체는 Heap 영역에 저장
--> 객체를 생성해서 저장되는 공간이기에 다른 곳에서 변수에 담아주면
--> 객체가 담겨지는게 아닌 객체의 메모리 위치를 담는 것

Stack 영역 이해하기
--> 메소드가 호출될 때 마다 Stack 영역에 메모리가 할당
--> 하나의 접시(스택 프레임)에 각 메서드의 지역변수가 저장
--> 이 영역은 접시 쌓듯 LIFO(Last In First Out) - 후입 선출
--> 메서드 시작 되면 추가되고 종료되면 사라지는 구조
--> 특정 메서드 실행 되면 메서드 정보와 변수가 Stack에 저장되고 끝나면 제거
--> 메서드 내 선언된 지역변수들이 저장되는 공간
--> 변수에 객체 담기면 객체 주소값이 저장

2-3 래퍼클래스(기본형 참조형)
래퍼클래스?
기본자료형을 객체로 감싸는 클래스
기본자료형 래퍼클래스
byte Byte
short Short
int Integer
long Long
float Float
double Double
char Character
boolean Boolean

기본형(자료형)
참조형? 변수에 객체가 담기면 해당 변수를 참조형 변수라고 함
참조형 변수는 데이터가 저장된 메모리 주소를 가리킴 --> Heap 메모리 주소
객체 데이터는 Heap 영역에 저장되어 있기 때문
객체, 배열 등이 참조형에 속함

래퍼클래스 활용
public static void main(String[] args) {
        int a = 1;
        System.out.println("a = " + a);

        Person personA = new Person("h", 3);
        System.out.println("person = " + personA);

        int[] arr = {1, 2, 3, 4, 5};
        System.out.println("arr = " + arr);

        // 래퍼클래스(기본형 변수를 감싸고 있는 클래스)
        // 참조형 변수 입니다
        Integer num = 100;
        System.out.println("num = " + num);
        // 이렇게 하면 래퍼클래스는 바로 값이 나옴
        // 래퍼클래스는 내부 처리가 되어있기에 참조형 변수라도 값인 숫자가 출력

        // Integer 래퍼클래스 기능 중 toString이 있다
        String numStr = num.toString();

        // 직접 만든 래퍼클래스
        CustomInteger myInteger = new CustomInteger(10);
        String myStrInteger = myInteger.toString();
        System.out.println("myStrInteger = " + myStrInteger);
    }

오토박싱 vs 언박싱
래퍼클래스와 기본형 사이 형변환 굉장히 자주 일어남
Java 에서는 이러한 형 변환을 자동 지원

오토박싱
기본형 -> 래퍼형 으로 변환하는 과정 오토박싱
Integer num3 = 10; --> 오토박싱
내부적으로 기본형 -> 래퍼형으로 자동처리

오토언박싱(언박싱)
래퍼형 -> 기본형 으로 변환하는 과정 오토언박싱
Integer num3 = 10;
int num = num3; --> 오토언박싱
내부적으로 래퍼형 -> 기본형으로 자동 처리

기본형과 래퍼형 성능 비교
래퍼형은 내부적으로 데이터 감싸고 있기에 연산시 기본형보다 느림,
빠른작업 시엔 기본형 쓰는게 좋은 작업


2-4 static
static 키워드 --> 모든 객체가 함께 사용하는 변수나 메서드 만들 때 사용
객체(인스턴스) 만들지 않아도 클래스 이름만으로 사용 가능
모든 객체가 같은 값 공유
static 변수와 메서드는 한 번만 생성, Method Area(메서드 영역)에 저장
static 키워드는 변수,  메서드에 붙일 수 있다.

인스턴스 멤버(인스턴스 변수 + 인스턴스 메서드)?
객체를 만들때 마다 생성되는 변수와 메서드
객체 생성 후에만 사용 가능
각 객체가 개별적 값,
Heap 영역에 위치

인스턴스 메서드?
객체 속성 활용하는 메서드, 객체 생성 후에만 사용 가능

클래스 멤버(클래스 변수 + 클래스 메서드)
클래스 자체에 속하는 변수와 메서드 의미
static 키워드 사용해서 선언합니다

주의사항
static - 공용 사용할 변수, 메서드에만 적용해야
static 메서드에서 this.로 인스턴스 변수 접근 X - 인스턴스 객체 생성이 우선되어야 하기 때문
static 꼭 필요할 때만 사용해야 - 변수와 메모리는 프로그램이 종료될 때 까지 메모리에 유지되기에

2-5 final
--> 변수는 변경이 불가능하게
--> 클래스는 상속할 수 없게
--> 메서드는 수정할 수 없게(오버라이딩 불가)

상수 - 변하지 않고 항상 일정한 값 갖는 수
--> Java 에선 대문자로 표현하는게 관례
--> 실행중 절대 변경되서는 안되기에 static final 키워드로 선언

불변객체
--> 내부 상태를 변경할 수 없는 객체
--> final을 속성에 활용(property, field)
--> 세터 없이 설계(내부 상태 변경 X기에)
--> 변경 필요 경우 새로운 객체 만들어야
--> String, Integer, 래퍼클래스 등


2-6 인터페이스
인터페이스